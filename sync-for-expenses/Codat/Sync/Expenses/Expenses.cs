
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Codat.Sync.Expenses
{
    using Codat.Sync.Expenses.Models.Errors;
    using Codat.Sync.Expenses.Models.Operations;
    using Codat.Sync.Expenses.Models.Shared;
    using Codat.Sync.Expenses.Utils;
    using Newtonsoft.Json;
    using System.Collections.Generic;
    using System.Net.Http.Headers;
    using System.Net.Http;
    using System.Threading.Tasks;
    using System;

    /// <summary>
    /// Create expense transactions.
    /// </summary>
    public interface IExpenses
    {

        /// <summary>
        /// Create expense transaction
        /// 
        /// <remarks>
        /// The *Create expense* endpoint creates an <a href="https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction">expense transaction</a> in the accounting platform for a given company&apos;s connection. <br/>
        /// <br/>
        /// <a href="https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction">Expense transactions</a> represent transactions made with a company debit or credit card. <br/>
        /// <br/>
        /// <br/>
        /// **Integration-specific behaviour**<br/>
        /// <br/>
        /// Some accounting platforms support the option of pushing transactions to a draft state. This can be done by setting the postAsDraft property on the transaction to true. For platforms without this feature, the postAsDraft property should be ignored or set to false.<br/>
        /// <br/>
        /// | Integration | Draft State | Details                                                                                                      |  <br/>
        /// |-------------|-------------|--------------------------------------------------------------------------------------------------------------|<br/>
        /// | Dynamics 365 Business Central | Yes   | Setting postAsDraft to true will push the transactions to a drafted state rather than posting directly to the ledger. For transactions in a draft state, they can then be approved and posted within the accounting platform. |<br/>
        /// | Quickbooks Online | No | -  |<br/>
        /// | Xero | No | - |<br/>
        /// | NetSuite | No | - |
        /// </remarks>
        /// </summary>
        Task<CreateExpenseTransactionResponse> CreateAsync(CreateExpenseTransactionRequest request);

        /// <summary>
        /// Update expense transactions
        /// 
        /// <remarks>
        /// The *Update expense* endpoint updates an existing <a href="https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction">expense transaction</a> in the accounting platform for a given company&apos;s connection. <br/>
        /// <br/>
        /// <a href="https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction">Expense transactions</a> represent transactions made with a company debit or credit card. <br/>
        /// <br/>
        /// <br/>
        /// **Integration-specific behaviour**<br/>
        /// <br/>
        /// At the moment you can update expenses only for Xero (<a href="https://docs.codat.io/expenses/sync-process/expense-transactions#transaction-types">Payment</a> transaction type only).
        /// </remarks>
        /// </summary>
        Task<UpdateExpenseTransactionResponse> UpdateAsync(UpdateExpenseTransactionRequest request);
    }

    /// <summary>
    /// Create expense transactions.
    /// </summary>
    public class Expenses: IExpenses
    {
        public SDKConfig SDKConfiguration { get; private set; }
        private const string _language = "csharp";
        private const string _sdkVersion = "5.3.0";
        private const string _sdkGenVersion = "2.301.2";
        private const string _openapiDocVersion = "prealpha";
        private const string _userAgent = "speakeasy-sdk/csharp 5.3.0 2.301.2 prealpha Codat.Sync.Expenses";
        private string _serverUrl = "";
        private ISpeakeasyHttpClient _defaultClient;
        private Func<Security>? _securitySource;

        public Expenses(ISpeakeasyHttpClient defaultClient, Func<Security>? securitySource, string serverUrl, SDKConfig config)
        {
            _defaultClient = defaultClient;
            _securitySource = securitySource;
            _serverUrl = serverUrl;
            SDKConfiguration = config;
        }

        public async Task<CreateExpenseTransactionResponse> CreateAsync(CreateExpenseTransactionRequest request)
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerDetails();
            var urlString = URLBuilder.Build(baseUrl, "/companies/{companyId}/sync/expenses/data/expense-transactions", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Post, urlString);
            httpRequest.Headers.Add("user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "CreateExpenseRequest", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            var client = _defaultClient;
            if (_securitySource != null)
            {
                client = SecuritySerializer.Apply(_defaultClient, _securitySource);
            }

            var httpResponse = await client.SendAsync(httpRequest);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            var response = new CreateExpenseTransactionResponse
            {
                StatusCode = (int)httpResponse.StatusCode,
                ContentType = contentType,
                RawResponse = httpResponse
            };
            if (response.StatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json",response.ContentType))
                {                    
                    var obj = ResponseBodyDeserializer.Deserialize<CreateExpenseResponse>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    response.CreateExpenseResponse = obj;
                }
                else
                {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
                }

            }
            else if (new List<int>{400, 401, 402, 403, 404, 429, 500, 503}.Contains(response.StatusCode))
            {
                if(Utilities.IsContentTypeMatch("application/json",response.ContentType))
                {                    
                    var obj = ResponseBodyDeserializer.Deserialize<ErrorMessage>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    throw obj!;
                }
                else
                {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
                }

            }
            else if (response.StatusCode >= 400 && response.StatusCode < 500 || response.StatusCode >= 500 && response.StatusCode < 600)
            {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);

            }
            else
            {
                throw new SDKException("unknown status code received", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            return response;
        }


        public async Task<UpdateExpenseTransactionResponse> UpdateAsync(UpdateExpenseTransactionRequest request)
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerDetails();
            var urlString = URLBuilder.Build(baseUrl, "/companies/{companyId}/sync/expenses/expense-transactions/{transactionId}", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "UpdateExpenseRequest", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            var client = _defaultClient;
            if (_securitySource != null)
            {
                client = SecuritySerializer.Apply(_defaultClient, _securitySource);
            }

            var httpResponse = await client.SendAsync(httpRequest);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            var response = new UpdateExpenseTransactionResponse
            {
                StatusCode = (int)httpResponse.StatusCode,
                ContentType = contentType,
                RawResponse = httpResponse
            };
            if (response.StatusCode == 202)
            {
                if(Utilities.IsContentTypeMatch("application/json",response.ContentType))
                {                    
                    var obj = ResponseBodyDeserializer.Deserialize<UpdateExpenseResponse>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    response.UpdateExpenseResponse = obj;
                }
                else
                {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
                }

            }
            else if (new List<int>{400, 401, 402, 403, 404, 422, 429, 500, 503}.Contains(response.StatusCode))
            {
                if(Utilities.IsContentTypeMatch("application/json",response.ContentType))
                {                    
                    var obj = ResponseBodyDeserializer.Deserialize<ErrorMessage>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    throw obj!;
                }
                else
                {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
                }

            }
            else if (response.StatusCode >= 400 && response.StatusCode < 500 || response.StatusCode >= 500 && response.StatusCode < 600)
            {
                throw new SDKException("API error occurred", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);

            }
            else
            {
                throw new SDKException("unknown status code received", (int)httpResponse.StatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            return response;
        }

    }
}